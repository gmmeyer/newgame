<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survivor 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }

        /* HUD Styles */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
        }
        #health-bar-container {
            width: 300px;
            height: 25px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #ff6b6b, #c0392b);
            transition: width 0.2s;
        }
        #exp-bar-container {
            width: 300px;
            height: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        #exp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            transition: width 0.2s;
        }
        #stats {
            margin-top: 10px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 18px;
        }
        #stats div {
            margin: 5px 0;
        }
        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #kill-count {
            position: absolute;
            top: 60px;
            right: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #difficulty-tier {
            position: absolute;
            top: 100px;
            right: 20px;
            color: #f1c40f;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #wave-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px #c0392b;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        /* Level Up Screen */
        #level-up-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #level-up-screen h1 {
            color: #f1c40f;
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 0 20px #f39c12;
        }
        #upgrade-options {
            display: flex;
            gap: 20px;
        }
        .upgrade-card {
            width: 200px;
            padding: 20px;
            background: linear-gradient(to bottom, #2c3e50, #1a252f);
            border: 3px solid #3498db;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .upgrade-card:hover {
            transform: scale(1.1);
            border-color: #f1c40f;
            box-shadow: 0 0 30px rgba(241, 196, 15, 0.5);
        }
        .upgrade-card h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 20px;
        }
        .upgrade-card p {
            font-size: 14px;
            color: #bdc3c7;
        }

        /* Game Over Screen */
        #game-over-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #game-over-screen h1 {
            color: #e74c3c;
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #c0392b;
        }
        #final-stats {
            color: #fff;
            font-size: 24px;
            margin-bottom: 40px;
            text-align: center;
        }
        #final-stats div {
            margin: 10px 0;
        }
        #restart-btn {
            padding: 15px 50px;
            font-size: 24px;
            background: linear-gradient(to bottom, #27ae60, #1e8449);
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        #restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(39, 174, 96, 0.5);
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #start-screen h1 {
            color: #e94560;
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #e94560;
        }
        #start-screen p {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
        }
        #start-btn {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(to bottom, #e94560, #c23a51);
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        #start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(233, 69, 96, 0.6);
        }
        #controls-info {
            margin-top: 40px;
            color: #7f8c8d;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Start Screen -->
        <div id="start-screen">
            <h1>SURVIVOR 3D</h1>
            <p>Survive the endless horde!</p>
            <button id="start-btn">START GAME</button>
            <div id="controls-info">
                WASD to move | Survive as long as you can!
            </div>
        </div>

        <!-- HUD -->
        <div id="hud" style="display: none;">
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
            <div id="exp-bar-container">
                <div id="exp-bar"></div>
            </div>
            <div id="stats">
                <div>Level: <span id="level">1</span></div>
            </div>
            <div id="timer">00:00</div>
            <div id="kill-count">Kills: 0</div>
            <div id="difficulty-tier">Difficulty: I</div>
            <div id="wave-warning"></div>
        </div>

        <!-- Level Up Screen -->
        <div id="level-up-screen">
            <h1>LEVEL UP!</h1>
            <div id="upgrade-options"></div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h1>GAME OVER</h1>
            <div id="final-stats">
                <div>Time Survived: <span id="final-time">00:00</span></div>
                <div>Level Reached: <span id="final-level">1</span></div>
                <div>Enemies Killed: <span id="final-kills">0</span></div>
            </div>
            <button id="restart-btn">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            LEVEL_UP: 'level_up',
            GAME_OVER: 'game_over'
        };

        let currentState = GameState.MENU;
        let scene, camera, renderer;
        let player, ground;
        let enemies = [];
        let projectiles = [];
        let gems = [];
        let clock;

        // Player stats
        let playerStats = {
            health: 100,
            maxHealth: 100,
            speed: 8,
            exp: 0,
            expToLevel: 10,
            level: 1,
            damage: 25,
            attackSpeed: 1,
            attackRange: 15,
            projectileSpeed: 20,
            projectileCount: 1,
            killCount: 0
        };

        // Game settings
        let gameTime = 0;
        let lastAttackTime = 0;
        let spawnInterval = 2;
        let lastSpawnTime = 0;
        let difficultyMultiplier = 1;
        let currentDifficultyTier = 1;
        let lastBossSpawnTime = -60;
        let enemyProjectiles = [];

        // Difficulty tiers and enemy unlocks
        const difficultyTiers = [
            { time: 0, name: 'I', enemies: ['basic', 'fast'] },
            { time: 30, name: 'II', enemies: ['basic', 'fast', 'tank'] },
            { time: 60, name: 'III', enemies: ['basic', 'fast', 'tank', 'exploder'] },
            { time: 90, name: 'IV', enemies: ['basic', 'fast', 'tank', 'exploder', 'splitter'] },
            { time: 120, name: 'V', enemies: ['basic', 'fast', 'tank', 'exploder', 'splitter', 'shooter'] },
            { time: 180, name: 'VI', enemies: ['basic', 'fast', 'tank', 'exploder', 'splitter', 'shooter', 'ghost'] },
            { time: 240, name: 'VII', enemies: ['basic', 'fast', 'tank', 'exploder', 'splitter', 'shooter', 'ghost', 'teleporter'] },
            { time: 300, name: 'VIII', enemies: ['elite_basic', 'elite_fast', 'tank', 'exploder', 'splitter', 'shooter', 'ghost', 'teleporter'] }
        ];

        // Enemy type definitions
        const enemyTypes = {
            basic: {
                geometry: () => new THREE.BoxGeometry(0.8, 0.8, 0.8),
                color: 0xe74c3c,
                emissive: 0x922b21,
                health: 30,
                speed: 3,
                damage: 10,
                scale: 1,
                weight: 40,
                gemCount: () => Math.ceil(Math.random() * 2)
            },
            fast: {
                geometry: () => new THREE.ConeGeometry(0.4, 1, 8),
                color: 0x9b59b6,
                emissive: 0x6c3483,
                health: 15,
                speed: 7,
                damage: 5,
                scale: 0.8,
                weight: 25,
                gemCount: () => 1
            },
            tank: {
                geometry: () => new THREE.SphereGeometry(0.7, 16, 16),
                color: 0x27ae60,
                emissive: 0x1e8449,
                health: 100,
                speed: 1.5,
                damage: 25,
                scale: 1.5,
                weight: 15,
                gemCount: () => Math.ceil(Math.random() * 3) + 2
            },
            exploder: {
                geometry: () => new THREE.DodecahedronGeometry(0.5, 0),
                color: 0xff6600,
                emissive: 0xcc4400,
                health: 25,
                speed: 4,
                damage: 8,
                scale: 1,
                weight: 20,
                explosionRadius: 4,
                explosionDamage: 30,
                gemCount: () => Math.ceil(Math.random() * 2)
            },
            splitter: {
                geometry: () => new THREE.IcosahedronGeometry(0.6, 0),
                color: 0x00bcd4,
                emissive: 0x008ba3,
                health: 40,
                speed: 2.5,
                damage: 12,
                scale: 1.2,
                weight: 15,
                splitCount: 3,
                gemCount: () => 1
            },
            splitter_child: {
                geometry: () => new THREE.IcosahedronGeometry(0.3, 0),
                color: 0x4dd0e1,
                emissive: 0x00acc1,
                health: 15,
                speed: 5,
                damage: 5,
                scale: 0.6,
                weight: 0,
                gemCount: () => 1
            },
            shooter: {
                geometry: () => new THREE.OctahedronGeometry(0.5, 0),
                color: 0xffeb3b,
                emissive: 0xfbc02d,
                health: 35,
                speed: 2,
                damage: 5,
                scale: 1,
                weight: 15,
                shootRange: 15,
                shootCooldown: 2,
                projectileDamage: 15,
                gemCount: () => Math.ceil(Math.random() * 2) + 1
            },
            ghost: {
                geometry: () => new THREE.TetrahedronGeometry(0.6, 0),
                color: 0xffffff,
                emissive: 0xaaaaaa,
                health: 20,
                speed: 4,
                damage: 15,
                scale: 1,
                weight: 10,
                transparent: true,
                phaseInterval: 1.5,
                gemCount: () => Math.ceil(Math.random() * 2)
            },
            teleporter: {
                geometry: () => new THREE.TorusGeometry(0.4, 0.15, 8, 16),
                color: 0xff00ff,
                emissive: 0xaa00aa,
                health: 30,
                speed: 3,
                damage: 20,
                scale: 1,
                weight: 10,
                teleportCooldown: 3,
                teleportRange: 8,
                gemCount: () => Math.ceil(Math.random() * 3)
            },
            elite_basic: {
                geometry: () => new THREE.BoxGeometry(1, 1, 1),
                color: 0xff0000,
                emissive: 0xaa0000,
                health: 150,
                speed: 4,
                damage: 20,
                scale: 1.3,
                weight: 20,
                isElite: true,
                gemCount: () => Math.ceil(Math.random() * 3) + 2
            },
            elite_fast: {
                geometry: () => new THREE.ConeGeometry(0.5, 1.2, 8),
                color: 0xff00ff,
                emissive: 0xaa00aa,
                health: 50,
                speed: 10,
                damage: 12,
                scale: 1,
                weight: 15,
                isElite: true,
                gemCount: () => Math.ceil(Math.random() * 2) + 1
            },
            boss: {
                geometry: () => new THREE.BoxGeometry(1.5, 1.5, 1.5),
                color: 0x8b0000,
                emissive: 0x660000,
                health: 500,
                speed: 2,
                damage: 40,
                scale: 2.5,
                weight: 0,
                isBoss: true,
                gemCount: () => 10 + Math.floor(Math.random() * 10)
            }
        };

        // Input
        const keys = {};

        // Upgrades
        const upgrades = [
            { name: 'Max Health', desc: '+20 Max HP', apply: () => { playerStats.maxHealth += 20; playerStats.health = Math.min(playerStats.health + 20, playerStats.maxHealth); }},
            { name: 'Speed', desc: '+15% Movement', apply: () => { playerStats.speed *= 1.15; }},
            { name: 'Damage', desc: '+10 Attack Damage', apply: () => { playerStats.damage += 10; }},
            { name: 'Attack Speed', desc: '+20% Fire Rate', apply: () => { playerStats.attackSpeed *= 1.2; }},
            { name: 'Range', desc: '+3 Attack Range', apply: () => { playerStats.attackRange += 3; }},
            { name: 'Multi-Shot', desc: '+1 Projectile', apply: () => { playerStats.projectileCount += 1; }},
            { name: 'Heal', desc: 'Restore 50 HP', apply: () => { playerStats.health = Math.min(playerStats.health + 50, playerStats.maxHealth); }},
            { name: 'Projectile Speed', desc: '+25% Bullet Speed', apply: () => { playerStats.projectileSpeed *= 1.25; }}
        ];

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Point light on player
            const playerLight = new THREE.PointLight(0x3498db, 1, 20);
            playerLight.position.set(0, 5, 0);
            scene.add(playerLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2c3e50,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid overlay
            const gridHelper = new THREE.GridHelper(100, 50, 0x3498db, 0x1a252f);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Player
            createPlayer();

            // Clock
            clock = new THREE.Clock();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // Initial render
            renderer.render(scene, camera);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.5, 1, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x3498db,
                emissive: 0x1a5276,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            playerGroup.add(body);

            // Glow ring
            const ringGeometry = new THREE.RingGeometry(0.8, 1, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x3498db,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.05;
            playerGroup.add(ring);

            player = playerGroup;
            scene.add(player);
        }

        function getCurrentTier() {
            for (let i = difficultyTiers.length - 1; i >= 0; i--) {
                if (gameTime >= difficultyTiers[i].time) {
                    return difficultyTiers[i];
                }
            }
            return difficultyTiers[0];
        }

        function selectEnemyType() {
            const tier = getCurrentTier();
            const availableTypes = tier.enemies;

            // Weighted random selection
            let totalWeight = 0;
            const weights = [];
            for (const typeName of availableTypes) {
                const type = enemyTypes[typeName];
                totalWeight += type.weight;
                weights.push({ name: typeName, weight: type.weight });
            }

            let random = Math.random() * totalWeight;
            for (const w of weights) {
                random -= w.weight;
                if (random <= 0) {
                    return w.name;
                }
            }
            return availableTypes[0];
        }

        function createEnemy(x, z, forcedType = null) {
            const enemyGroup = new THREE.Group();
            const typeName = forcedType || selectEnemyType();
            const type = enemyTypes[typeName];

            const geometry = type.geometry();
            const material = new THREE.MeshStandardMaterial({
                color: type.color,
                emissive: type.emissive,
                emissiveIntensity: type.isElite ? 0.5 : 0.2,
                transparent: type.transparent || false,
                opacity: type.transparent ? 0.6 : 1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 0.5 * type.scale;
            mesh.castShadow = true;
            mesh.scale.set(type.scale, type.scale, type.scale);
            enemyGroup.add(mesh);

            // Add glow ring for elite/boss enemies
            if (type.isElite || type.isBoss) {
                const ringGeometry = new THREE.RingGeometry(type.scale * 0.8, type.scale * 1.0, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: type.isBoss ? 0xff0000 : 0xffff00,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.05;
                enemyGroup.add(ring);
            }

            enemyGroup.position.set(x, 0, z);

            const health = type.health * difficultyMultiplier;
            enemyGroup.userData = {
                type: typeName,
                health,
                maxHealth: health,
                speed: type.speed,
                damage: type.damage,
                scale: type.scale,
                lastDamageTime: 0,
                lastShootTime: 0,
                lastTeleportTime: 0,
                lastPhaseTime: 0,
                phased: false,
                explosionRadius: type.explosionRadius,
                explosionDamage: type.explosionDamage,
                splitCount: type.splitCount,
                shootRange: type.shootRange,
                shootCooldown: type.shootCooldown,
                projectileDamage: type.projectileDamage,
                teleportCooldown: type.teleportCooldown,
                teleportRange: type.teleportRange,
                phaseInterval: type.phaseInterval,
                isElite: type.isElite,
                isBoss: type.isBoss,
                gemCount: type.gemCount
            };

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
            return enemyGroup;
        }

        function createExplosion(x, z, radius, damage) {
            // Visual explosion
            const explosionGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.set(x, 0.5, z);
            scene.add(explosion);

            // Animate explosion
            let scale = 0.5;
            const expandInterval = setInterval(() => {
                scale += 0.5;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.1;

                if (scale >= radius) {
                    clearInterval(expandInterval);
                    scene.remove(explosion);
                }
            }, 50);

            // Damage player if in range
            const distToPlayer = player.position.distanceTo(new THREE.Vector3(x, 0, z));
            if (distToPlayer < radius) {
                playerStats.health -= damage;
                player.children[0].material.emissive.setHex(0xff6600);
                setTimeout(() => {
                    player.children[0].material.emissive.setHex(0x1a5276);
                }, 200);

                if (playerStats.health <= 0) {
                    gameOver();
                }
            }
        }

        function createEnemyProjectile(fromPos, toPos, damage) {
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(fromPos);
            projectile.position.y = 1;

            const direction = new THREE.Vector3();
            direction.subVectors(toPos, fromPos).normalize();
            direction.y = 0;

            projectile.userData = {
                velocity: direction.multiplyScalar(12),
                damage: damage,
                lifetime: 3
            };

            scene.add(projectile);
            enemyProjectiles.push(projectile);
        }

        function createProjectile(direction, offset = 0) {
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xf1c40f,
                transparent: true,
                opacity: 0.9
            });
            const projectile = new THREE.Mesh(geometry, material);

            // Apply offset for multi-shot
            const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
            const offsetPosition = perpendicular.multiplyScalar(offset * 0.5);

            projectile.position.copy(player.position);
            projectile.position.y = 1;
            projectile.position.add(offsetPosition);

            projectile.userData = {
                velocity: direction.clone().multiplyScalar(playerStats.projectileSpeed),
                damage: playerStats.damage,
                lifetime: 2
            };

            scene.add(projectile);
            projectiles.push(projectile);
        }

        function createGem(x, z, value = 1) {
            const geometry = new THREE.OctahedronGeometry(0.3, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0x2ecc71,
                emissive: 0x27ae60,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            const gem = new THREE.Mesh(geometry, material);
            gem.position.set(x, 0.5, z);
            gem.userData = { value };

            scene.add(gem);
            gems.push(gem);
        }

        function showWaveWarning(message) {
            const warning = document.getElementById('wave-warning');
            warning.textContent = message;
            warning.style.opacity = '1';
            setTimeout(() => {
                warning.style.opacity = '0';
            }, 2000);
        }

        function spawnEnemies(deltaTime) {
            lastSpawnTime += deltaTime;

            // Increase difficulty over time
            difficultyMultiplier = 1 + (gameTime / 60) * 0.5;
            spawnInterval = Math.max(0.3, 2 - (gameTime / 60) * 0.3);

            // Check for tier change
            const newTier = getCurrentTier();
            const tierIndex = difficultyTiers.indexOf(newTier) + 1;
            if (tierIndex > currentDifficultyTier) {
                currentDifficultyTier = tierIndex;
                showWaveWarning(`DIFFICULTY ${newTier.name} - New enemies incoming!`);
            }

            // Spawn boss every 60 seconds after first minute
            if (gameTime >= 60 && gameTime - lastBossSpawnTime >= 60) {
                lastBossSpawnTime = gameTime;
                const angle = Math.random() * Math.PI * 2;
                const distance = 35;
                const x = player.position.x + Math.cos(angle) * distance;
                const z = player.position.z + Math.sin(angle) * distance;
                createEnemy(x, z, 'boss');
                showWaveWarning('BOSS INCOMING!');
            }

            if (lastSpawnTime >= spawnInterval) {
                lastSpawnTime = 0;

                // Spawn from outside the visible area
                const spawnCount = Math.min(1 + Math.floor(gameTime / 30), 8);

                for (let i = 0; i < spawnCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 10;
                    const x = player.position.x + Math.cos(angle) * distance;
                    const z = player.position.z + Math.sin(angle) * distance;
                    createEnemy(x, z);
                }
            }
        }

        function findNearestEnemy() {
            let nearest = null;
            let nearestDist = Infinity;

            for (const enemy of enemies) {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < nearestDist && dist <= playerStats.attackRange) {
                    nearestDist = dist;
                    nearest = enemy;
                }
            }

            return nearest;
        }

        function attack(deltaTime) {
            lastAttackTime += deltaTime;
            const attackInterval = 1 / playerStats.attackSpeed;

            if (lastAttackTime >= attackInterval) {
                const nearestEnemy = findNearestEnemy();

                if (nearestEnemy) {
                    lastAttackTime = 0;

                    const direction = new THREE.Vector3();
                    direction.subVectors(nearestEnemy.position, player.position).normalize();
                    direction.y = 0;

                    // Multi-shot
                    const count = playerStats.projectileCount;
                    for (let i = 0; i < count; i++) {
                        const offset = count === 1 ? 0 : (i - (count - 1) / 2);
                        createProjectile(direction, offset);
                    }
                }
            }
        }

        function updatePlayer(deltaTime) {
            const velocity = new THREE.Vector3();

            if (keys['w']) velocity.z -= 1;
            if (keys['s']) velocity.z += 1;
            if (keys['a']) velocity.x -= 1;
            if (keys['d']) velocity.x += 1;

            if (velocity.length() > 0) {
                velocity.normalize();
                velocity.multiplyScalar(playerStats.speed * deltaTime);
                player.position.add(velocity);

                // Boundary
                player.position.x = Math.max(-45, Math.min(45, player.position.x));
                player.position.z = Math.max(-45, Math.min(45, player.position.z));
            }

            // Rotate glow ring
            player.children[1].rotation.z += deltaTime * 2;

            // Update camera to follow player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 20;
            camera.lookAt(player.position.x, 0, player.position.z);
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const data = enemy.userData;
                const distToPlayer = player.position.distanceTo(enemy.position);

                // Ghost phasing behavior
                if (data.phaseInterval) {
                    if (gameTime - data.lastPhaseTime >= data.phaseInterval) {
                        data.lastPhaseTime = gameTime;
                        data.phased = !data.phased;
                        enemy.children[0].material.opacity = data.phased ? 0.2 : 0.6;
                    }
                }

                // Teleporter behavior
                if (data.teleportCooldown && distToPlayer < 20) {
                    if (gameTime - data.lastTeleportTime >= data.teleportCooldown) {
                        data.lastTeleportTime = gameTime;
                        // Teleport closer to player
                        const angle = Math.random() * Math.PI * 2;
                        const teleportDist = 3 + Math.random() * data.teleportRange;
                        enemy.position.x = player.position.x + Math.cos(angle) * teleportDist;
                        enemy.position.z = player.position.z + Math.sin(angle) * teleportDist;

                        // Teleport visual effect
                        enemy.children[0].material.emissive.setHex(0xffffff);
                        setTimeout(() => {
                            if (enemy.children[0]) {
                                enemy.children[0].material.emissive.setHex(0xaa00aa);
                            }
                        }, 100);
                    }
                }

                // Shooter behavior
                if (data.shootRange && distToPlayer <= data.shootRange && distToPlayer > 3) {
                    if (gameTime - data.lastShootTime >= data.shootCooldown) {
                        data.lastShootTime = gameTime;
                        createEnemyProjectile(enemy.position, player.position, data.projectileDamage);
                    }
                    // Shooters try to keep distance
                    if (distToPlayer < 8) {
                        const awayDirection = new THREE.Vector3();
                        awayDirection.subVectors(enemy.position, player.position).normalize();
                        awayDirection.y = 0;
                        enemy.position.add(awayDirection.multiplyScalar(data.speed * 0.5 * deltaTime));
                    }
                } else {
                    // Normal movement towards player
                    const direction = new THREE.Vector3();
                    direction.subVectors(player.position, enemy.position).normalize();
                    direction.y = 0;
                    enemy.position.add(direction.multiplyScalar(data.speed * deltaTime));
                }

                // Rotate enemy
                enemy.children[0].rotation.y += deltaTime * 2;
                enemy.children[0].rotation.x += deltaTime;

                // Rotate elite/boss ring
                if (enemy.children[1]) {
                    enemy.children[1].rotation.z += deltaTime * 3;
                }

                // Check collision with player (ghosts can only hit when not phased)
                const collisionDist = data.isBoss ? 3 : 1.5;
                if (distToPlayer < collisionDist && !data.phased) {
                    if (gameTime - data.lastDamageTime > 0.5) {
                        data.lastDamageTime = gameTime;
                        playerStats.health -= data.damage;

                        // Flash player red
                        player.children[0].material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            player.children[0].material.emissive.setHex(0x1a5276);
                        }, 100);

                        if (playerStats.health <= 0) {
                            gameOver();
                            return;
                        }
                    }
                }

                // Remove if too far (but not bosses)
                if (!data.isBoss && distToPlayer > 60) {
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
        }

        function updateEnemyProjectiles(deltaTime) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const projectile = enemyProjectiles[i];

                // Move projectile
                projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
                projectile.userData.lifetime -= deltaTime;

                // Check collision with player
                const distToPlayer = player.position.distanceTo(projectile.position);
                if (distToPlayer < 1) {
                    playerStats.health -= projectile.userData.damage;
                    player.children[0].material.emissive.setHex(0xff0000);
                    setTimeout(() => {
                        player.children[0].material.emissive.setHex(0x1a5276);
                    }, 100);

                    scene.remove(projectile);
                    enemyProjectiles.splice(i, 1);

                    if (playerStats.health <= 0) {
                        gameOver();
                    }
                    continue;
                }

                // Remove if expired
                if (projectile.userData.lifetime <= 0) {
                    scene.remove(projectile);
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function handleEnemyDeath(enemy, index) {
            const data = enemy.userData;
            const x = enemy.position.x;
            const z = enemy.position.z;

            // Exploder death
            if (data.explosionRadius) {
                createExplosion(x, z, data.explosionRadius, data.explosionDamage);
            }

            // Splitter death
            if (data.splitCount) {
                for (let i = 0; i < data.splitCount; i++) {
                    const angle = (Math.PI * 2 / data.splitCount) * i;
                    const offsetX = Math.cos(angle) * 1.5;
                    const offsetZ = Math.sin(angle) * 1.5;
                    createEnemy(x + offsetX, z + offsetZ, 'splitter_child');
                }
            }

            // Drop gems
            const gemCount = data.gemCount();
            const gemValue = data.isBoss ? 3 : (data.isElite ? 2 : 1);
            for (let k = 0; k < gemCount; k++) {
                const offsetX = (Math.random() - 0.5) * 3;
                const offsetZ = (Math.random() - 0.5) * 3;
                createGem(x + offsetX, z + offsetZ, gemValue);
            }

            scene.remove(enemy);
            enemies.splice(index, 1);
            playerStats.killCount++;
        }

        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];

                // Move projectile
                projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
                projectile.userData.lifetime -= deltaTime;

                // Check collision with enemies
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const data = enemy.userData;

                    // Ghosts can only be hit when not phased
                    if (data.phased) continue;

                    const hitRadius = data.isBoss ? 2 : 1;
                    const dist = projectile.position.distanceTo(enemy.position);

                    if (dist < hitRadius) {
                        data.health -= projectile.userData.damage;

                        // Flash enemy white
                        enemy.children[0].material.emissive.setHex(0xffffff);
                        const originalEmissive = enemyTypes[data.type]?.emissive || 0x922b21;
                        setTimeout(() => {
                            if (enemy.children[0]) {
                                enemy.children[0].material.emissive.setHex(originalEmissive);
                            }
                        }, 50);

                        if (data.health <= 0) {
                            handleEnemyDeath(enemy, j);
                        }

                        hit = true;
                        break;
                    }
                }

                // Remove projectile if hit or expired
                if (hit || projectile.userData.lifetime <= 0) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateGems(deltaTime) {
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];

                // Rotate gems
                gem.rotation.y += deltaTime * 3;
                gem.position.y = 0.5 + Math.sin(gameTime * 3 + i) * 0.1;

                // Magnet effect when close to player
                const dist = player.position.distanceTo(gem.position);
                if (dist < 5) {
                    const direction = new THREE.Vector3();
                    direction.subVectors(player.position, gem.position).normalize();
                    gem.position.add(direction.multiplyScalar(10 * deltaTime));
                }

                // Collect gem
                if (dist < 1) {
                    playerStats.exp += gem.userData.value;
                    scene.remove(gem);
                    gems.splice(i, 1);

                    // Check level up
                    if (playerStats.exp >= playerStats.expToLevel) {
                        levelUp();
                    }
                }
            }
        }

        function levelUp() {
            playerStats.exp -= playerStats.expToLevel;
            playerStats.expToLevel = Math.floor(playerStats.expToLevel * 1.5);
            playerStats.level++;

            currentState = GameState.LEVEL_UP;
            showLevelUpScreen();
        }

        function showLevelUpScreen() {
            const screen = document.getElementById('level-up-screen');
            const options = document.getElementById('upgrade-options');
            options.innerHTML = '';

            // Pick 3 random upgrades
            const shuffled = [...upgrades].sort(() => Math.random() - 0.5);
            const choices = shuffled.slice(0, 3);

            choices.forEach(upgrade => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.desc}</p>`;
                card.addEventListener('click', () => {
                    upgrade.apply();
                    hideLevelUpScreen();
                });
                options.appendChild(card);
            });

            screen.style.display = 'flex';
        }

        function hideLevelUpScreen() {
            document.getElementById('level-up-screen').style.display = 'none';
            currentState = GameState.PLAYING;
        }

        function updateHUD() {
            document.getElementById('health-bar').style.width =
                (playerStats.health / playerStats.maxHealth * 100) + '%';
            document.getElementById('exp-bar').style.width =
                (playerStats.exp / playerStats.expToLevel * 100) + '%';
            document.getElementById('level').textContent = playerStats.level;

            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            document.getElementById('timer').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('kill-count').textContent = `Kills: ${playerStats.killCount}`;

            const tier = getCurrentTier();
            document.getElementById('difficulty-tier').textContent = `Difficulty: ${tier.name}`;
        }

        function gameOver() {
            currentState = GameState.GAME_OVER;

            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);

            document.getElementById('final-time').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('final-level').textContent = playerStats.level;
            document.getElementById('final-kills').textContent = playerStats.killCount;

            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            currentState = GameState.PLAYING;
            clock.start();
            animate();
        }

        function restartGame() {
            // Reset player stats
            playerStats = {
                health: 100,
                maxHealth: 100,
                speed: 8,
                exp: 0,
                expToLevel: 10,
                level: 1,
                damage: 25,
                attackSpeed: 1,
                attackRange: 15,
                projectileSpeed: 20,
                projectileCount: 1,
                killCount: 0
            };

            // Clear enemies, projectiles, gems
            enemies.forEach(e => scene.remove(e));
            projectiles.forEach(p => scene.remove(p));
            enemyProjectiles.forEach(p => scene.remove(p));
            gems.forEach(g => scene.remove(g));
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            gems = [];

            // Reset player position
            player.position.set(0, 0, 0);

            // Reset game time and difficulty
            gameTime = 0;
            lastAttackTime = 0;
            lastSpawnTime = 0;
            difficultyMultiplier = 1;
            currentDifficultyTier = 1;
            lastBossSpawnTime = -60;

            // Hide game over, show HUD
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            currentState = GameState.PLAYING;
            clock.start();
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);

            if (currentState === GameState.PLAYING) {
                gameTime += deltaTime;

                updatePlayer(deltaTime);
                spawnEnemies(deltaTime);
                updateEnemies(deltaTime);
                attack(deltaTime);
                updateProjectiles(deltaTime);
                updateEnemyProjectiles(deltaTime);
                updateGems(deltaTime);
                updateHUD();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>
